{
  "metadata" : {
    "name" : "TESTE",
    "user_save_timestamp" : "1969-12-31T21:00:00.000Z",
    "auto_save_timestamp" : "1969-12-31T21:00:00.000Z",
    "language_info" : {
      "name" : "scala",
      "file_extension" : "scala",
      "codemirror_mode" : "text/x-scala"
    },
    "trusted" : true,
    "customLocalRepo" : null,
    "customRepos" : null,
    "customDeps" : null,
    "customImports" : null,
    "customArgs" : null,
    "customSparkConf" : null
  },
  "cells" : [ {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : true,
      "id" : "9C9786B964F9426C94D0B4E5C908E5D4"
    },
    "cell_type" : "code",
    "source" : "",
    "outputs" : [ ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : true,
      "id" : "1F30F02B7EC54822809EA1ED2D3B2753"
    },
    "cell_type" : "code",
    "source" : "",
    "outputs" : [ ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : true,
      "id" : "8133B781106B45F592B2853886AB5672"
    },
    "cell_type" : "code",
    "source" : "",
    "outputs" : [ ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "8D9895F4ED4F43FEAC4A6C3A7EB62209"
    },
    "cell_type" : "code",
    "source" : "import org.apache.spark.ml.Pipeline\nimport org.apache.spark.ml.PipelineModel\nimport org.apache.spark.ml.evaluation.RegressionEvaluator\nimport org.apache.spark.ml.feature.VectorIndexer\nimport org.apache.spark.ml.feature.VectorAssembler\nimport org.apache.spark.ml.regression.DecisionTreeRegressionModel\nimport org.apache.spark.ml.regression.DecisionTreeRegressor\nimport org.apache.spark.ml.tuning.{ParamGridBuilder, TrainValidationSplit}\nimport org.apache.spark.ml.tuning.TrainValidationSplitModel\n\nimport org.apache.spark.ml.regression.LinearRegression\nimport org.apache.spark.ml.feature.VectorAssembler\nimport org.apache.spark.ml.linalg.Vectors\n\nimport org.apache.spark.mllib.regression.LinearRegressionModel\nimport org.apache.spark.mllib.regression.LinearRegressionWithSGD\nimport org.apache.spark.mllib.regression.LassoModel\nimport org.apache.spark.mllib.regression.LassoWithSGD\nimport org.apache.spark.mllib.regression.RidgeRegressionModel\nimport org.apache.spark.mllib.regression.RidgeRegressionWithSGD\n\nimport org.apache.spark.sql.types.{StructType, StructField, StringType, IntegerType, TimestampType, DoubleType, DateType}\nimport org.apache.spark.sql.expressions.Window\nimport org.apache.spark.sql.functions._\nimport java.util.Calendar\nimport java.util.Date\nimport org.apache.spark.mllib.tree.model.DecisionTreeModel\n\nimport resource._\n\nval ROOT = \"/Users/flavio.clesio/Documents/spark-notebook-production/spark-notebook-0.7.0/notebooks/spark-summit-2017\"\n\nval session = SparkSession\n      .builder\n      .appName(\"DecisionTreePipeline\")\n      .getOrCreate()\n\n// data-sample.csv\n\n// You can monitoring all this stuff in: http://localhost:4040/jobs/\n\nval summarizedDataFrame = session.read.load(ROOT + \"/sbs-summarized-dataframe\").cache\n\nval carrierList = List(1)",
    "outputs" : [ ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "F7E968364F6245D694BC927335E346F4"
    },
    "cell_type" : "code",
    "source" : "val featureCols = Array(\"hour_of_day\", \"week_of_month\", \"avg_response_time\",\"no_credit\", \"errors\", \"total_attempts\")\n\nval assemblerSucccesful = new VectorAssembler().setInputCols(featureCols).setOutputCol(\"features_success\")\n\n// Dataframe with all of the  feature columns in  a vector column\nval summarizedDataFrame2 = assemblerSucccesful.transform(summarizedDataFrame)\n\nval dataWithLabels = summarizedDataFrame2.withColumn(\"successful_charges_log\", log($\"successful_charges\"))\n\nval dataWithLabelsFiltered = dataWithLabels.filter(\"successful_charges_log is not null\")\n\nval data = dataWithLabels.filter(s\"carrier_id = 1\")\n\nval Array(trainingData, testData) = data.randomSplit(Array(0.9, 0.1))\n\nval label  = \"successful_charges_log\"\nval features = \"features_success\"\nval predictionColumn = \"successful_charges\"\nval assembler = assemblerSucccesful",
    "outputs" : [ ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "F868323FEF2C4ABBAFED12FD17F8BE16"
    },
    "cell_type" : "code",
    "source" : "val lr_lasso = new LinearRegression()\n  .setMaxIter(100)\n  .setRegParam(0.5) // Parâmetro de força da regularização\n  .setElasticNetParam(1) // ElasticNet mixing parameter For alpha = 0 the penalty is an L2 penalty (Ridge), for alpha = 1 it is an L1 penalty (Lasso), for 0 < alpha < 1 the penalty is a combination of L1 and L2 (Elastic Net)\n  .setLabelCol(label) \n  .setFeaturesCol(features)\n  .setTol(10) // The convergence tolerance of iterations \n  .setPredictionCol(\"prediction_log\")\n\nval lr_ridge = new LinearRegression()\n  .setMaxIter(100)\n  .setRegParam(0.5) // Parâmetro de força da regularização\n  .setElasticNetParam(0) // ElasticNet mixing parameter For alpha = 0 the penalty is an L2 penalty (Ridge), for alpha = 1 it is an L1 penalty (Lasso), for 0 < alpha < 1 the penalty is a combination of L1 and L2 (Elastic Net)\n  .setLabelCol(label) \n  .setFeaturesCol(features)\n  .setTol(10) // The convergence tolerance of iterations \n  .setPredictionCol(\"prediction_log\")\n\nval lr_elastic_net = new LinearRegression()\n  .setMaxIter(100)\n  .setRegParam(0.8) // Parâmetro de força da regularização\n  .setElasticNetParam(0.8) // ElasticNet mixing parameter For alpha = 0 the penalty is an L2 penalty (Ridge), for alpha = 1 it is an L1 penalty (Lasso), for 0 < alpha < 1 the penalty is a combination of L1 and L2 (Elastic Net)\n  .setLabelCol(label) \n  .setFeaturesCol(features)\n  .setTol(10) // The convergence tolerance of iterations \n  .setPredictionCol(\"prediction_log\")",
    "outputs" : [ ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "E557C713478E45DBB904E9B47A59626F"
    },
    "cell_type" : "code",
    "source" : "//fitting the model\nval lr_lassoModel = lr_lasso.fit(trainingData)\nval lr_ridgeModel = lr_ridge.fit(trainingData)\nval lr_elastic_netModel = lr_elastic_net.fit(trainingData)\n\n// Summarize the model over the training set and print out some metrics\nval trainingSummary_lr_lassoModel = lr_lassoModel.summary\nval trainingSummary_lr_ridgeModel = lr_ridgeModel.summary\nval trainingSummary_lr_elastic_netModel = lr_elastic_netModel.summary",
    "outputs" : [ ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "47828DBEDB6C45748A7013DE27781ED1"
    },
    "cell_type" : "code",
    "source" : "println(s\"Lasso Model RMSE: ${trainingSummary_lr_lassoModel.rootMeanSquaredError}\")\nprintln(s\"Ridge Model RMSE: ${trainingSummary_lr_ridgeModel.rootMeanSquaredError}\")\nprintln(s\"Linear Model RMSE: ${trainingSummary_lr_elastic_netModel.rootMeanSquaredError}\")",
    "outputs" : [ ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : true,
      "id" : "93647518083442CF8FBAF32B84790EFA"
    },
    "cell_type" : "code",
    "source" : "",
    "outputs" : [ ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : true,
      "id" : "5013763D1E254C799865DB612745A9F4"
    },
    "cell_type" : "code",
    "source" : "",
    "outputs" : [ ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : true,
      "id" : "B39AD456D985481B83CDB799FCDC66BC"
    },
    "cell_type" : "code",
    "source" : "",
    "outputs" : [ ]
  } ],
  "nbformat" : 4
}